# Errors

<!--type=misc-->

Errors generated by Ruff fall into two categories: JavaScript errors and system
errors. All errors inherit from or are instances of JavaScript's [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
class and are guaranteed to provide *at least* the attributes available on that
class.

When an operation is not permitted due to language-syntax or
language-runtime-level reasons, a **JavaScript error** is generated and thrown
as an **exception**. If an operation is not allowed due to system-level
restrictions, a **system error** is generated. Client code is then given the
opportunity to **intercept** this error based on how the API **propagates** it.

The style of API called determines how generated errors are handed back, or
**propagated**, to client code, which in turn informs how the client may **intercept**
the error. Exceptions can be intercepted using the `try / catch` construct;
other propagation strategies are covered [below](#errors_error_propagation_and_interception).

## JavaScript Errors

<!--type=misc-->

JavaScript errors typically denote that an API is being used incorrectly, or that
there is a problem with the program as written.

### Class: Error

<!--type=class-->

A general error object. Unlike other error objects, `Error` instances do not
denote any specific circumstance of why the error occurred. Errors capture a
"stack trace" detailing the point in the program at which they were
instantiated, and may provide a description of the error.

**Note**: Ruff will generate this class of error to encapsulate system
errors as well as plain JavaScript errors.

#### new Error(message)

Instantiates a new Error object and sets its `.message` property to the provided
message. Its `.stack` will represent the point in the program at which `new Error`
was called. Stack traces are subject to [Duktape's stack trace API](https://github.com/svaarala/duktape/blob/master/doc/error-objects.rst).
Stack traces only extend to the beginning of synchronous code execution, *or* a number of frames given by
`Error.stackTraceLimit`, whichever is smaller.

#### error.message

A string of the value passed to `Error()` upon instantiation. The message will
also appear in the first line of the stack trace of the error. Changing this
property *may not* change the first line of the stack trace.

#### error.stack

A property that, when **accessed**, returns a string representing the point in the program
at which this error was instantiated. An example stacktrace follows:

    AssertionError: 6 == 9
      fail /Users/zhulizhong/ruff/ruff_modules/assert/src/index.js:93
      equal /Users/zhulizhong/ruff/ruff_modules/assert/src/index.js:119
      anon /Users/zhulizhong/ruff/ruff_modules/timers/test/timers_test.js:32 preventsyield
      anon  native strict preventsyield

The first line is formatted as `<error class name>: <error message>`, and it is followed
by a series of stack frames (each line beginning with method name). Each frame describes
a call site in the program that lead to the error being generated. Duktape attempts to
display a name for each function (by variable name, function name, or object
method name), but occasionally it will not be able to find a suitable name. 

Frames are **only** generated for JavaScript functions. If, for example, execution
synchronously passes through a C++ addon function called `cheetahify`, which itself
calls a JavaScript function, the frame representing the `cheetahify` call will **not**
be present in stacktraces:

```javascript
var cheetahify = require('./native-binding.node');

function makeFaster() {
  // cheetahify *synchronously* calls speedy.
  cheetahify(function speedy() {
    throw new Error('oh no!');
  });
}

makeFaster(); // will throw:
// /home/gbusey/file.js:6
//     throw new Error('oh no!');
//           ^
// Error: oh no!
//      makeFaster speedy (/home/gbusey/file.js:6:11)
//      fail /Users/zhulizhong/ruff/ruff_modules/assert/src/index.js:93
//      equal /Users/zhulizhong/ruff/ruff_modules/assert/src/index.js:119
//      anon /Users/zhulizhong/ruff/ruff_modules/timers/test/timers_test.js:32 preventsyield
//      anon  native strict preventsyield
```

The location information will be one of:

* `native`, if the frame represents a call internal to Duktape (as in `[].forEach`).
* `plain-filename.js:line:column`, if the frame represents a call internal to Ruff.
* `/absolute/path/to/file.js:line`, if the frame represents a call in a user program, or its dependencies.

It is important to note that the string representing the stacktrace is only
generated on **access**: it is lazily generated.

The number of frames captured by the stack trace is bounded by the smaller of
`Error.stackTraceLimit` or the number of available frames on the current event
loop tick.

System-level errors are generated as augmented Error instances, which are detailed
[below](#errors_system_errors).

#### Error.captureStackTrace(targetObject[, constructorOpt])

Creates a `.stack` property on `targetObject`, which when accessed returns
a string representing the location in the program at which `Error.captureStackTrace`
was called.

```javascript
var myObject = {};

Error.captureStackTrace(myObject);

myObject.stack  // similar to `new Error().stack`
```

The first line of the trace, instead of being prefixed with `ErrorType:
message`, will be the result of `targetObject.toString()`.

`constructorOpt` optionally accepts a function. If given, all frames above
`constructorOpt`, including `constructorOpt`, will be omitted from the generated
stack trace.

This is useful for hiding implementation details of error generation from the
end user. A common way of using this parameter is to pass the current Error
constructor to it:

```javascript

function MyError() {
  Error.captureStackTrace(this, MyError);
}

// without passing MyError to captureStackTrace, the MyError
// frame would should up in the .stack property. by passing
// the constructor, we omit that frame and all frames above it.
new MyError().stack

```

#### Error.stackTraceLimit

Property that determines the number of stack frames collected by a stack trace
(whether generated by `new Error().stack` or `Error.captureStackTrace(obj)`).

The initial value is `10`. It may be set to any valid JavaScript number, which
will affect any stack trace captured *after* the value has been changed. If set
to a non-number value, stack traces will not capture any frames and will report
`undefined` on access.

### Class: RangeError

A subclass of Error that indicates that a provided argument was not within the
set or range of acceptable values for a function; whether that be a numeric
range, or outside the set of options for a given function parameter. An example:

```javascript
require('net').connect(-1);  // throws RangeError, port should be > 0 && < 65536
```

Ruff will generate and throw RangeError instances *immediately* -- they are a form
of argument validation.

### Class: TypeError

A subclass of Error that indicates that a provided argument is not an allowable
type. For example, passing a function to a parameter which expects a string would
be considered a TypeError.

```javascript
require('url').parse(function() { }); // throws TypeError, since it expected a string
```

Ruff will generate and throw TypeError instances *immediately* -- they are a form
of argument validation.

### Class: ReferenceError

A subclass of Error that indicates that an attempt is being made to access a variable
that is not defined. Most commonly it indicates a typo, or an otherwise broken program.
While client code may generate and propagate these errors, in practice only Duktape will do
so.

```javascript
doesNotExist; // throws ReferenceError, doesNotExist is not a variable in this program.
```

ReferenceError instances will have an `.arguments` member that is an array containing
one element -- a string representing the variable that was not defined.

```javascript
try {
  doesNotExist;
} catch(err) {
  err.arguments[0] === 'doesNotExist';
}
```

Unless the userland program is dynamically generating and running code,
ReferenceErrors should always be considered a bug in the program, or its
dependencies.

### Class: SyntaxError

A subclass of Error that indicates that a program is not valid JavaScript.
These errors may only be generated and propagated as a result of code
evaluation. Code evaluation may happen as a result of `eval`, `Function`,
`require`, or [vm](vm.html). These errors are almost always indicative of a broken
program.

```javascript
try {
  require("vm").runInThisContext("binary ! isNotOk");
} catch(err) {
  // err will be a SyntaxError
}
```

SyntaxErrors are unrecoverable from the context that created them â€“ they may only be caught
by other contexts.

### Exceptions vs. Errors

<!--type=misc-->

A JavaScript "exception" is a value that is thrown as a result of an invalid operation or
as the target of a `throw` statement. While it is not required that these values inherit from
`Error`, all exceptions thrown by Ruff or the JavaScript runtime *will* be instances of Error.

Some exceptions are *unrecoverable* at the JavaScript layer. These exceptions will always bring
down the process. These are usually failed `assert()` checks or `abort()` calls in the C++ layer.
